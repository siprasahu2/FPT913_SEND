package com.TP.FPT913_SEND;


import java.util.*;
import com.synchronoss.ruleserver.core.xpath.XOMContainerBean;
import com.synchronoss.ruleserver.core.xpath.XOMAccessBean;
import com.wisor.brms.asog.xpath.XPathProcessor;
import com.wisor.brms.fpt.Populated;
import com.wisor.brms.fpt.Equals;
import com.wisor.brms.fpt.Contains;
import com.wisor.brms.fpt.LengthCheck;
import com.wisor.brms.fpt.Position;
import com.wisor.brms.fpt.DatatypeCheck;
import com.wisor.brms.fpt.SpaceCheck;
import com.wisor.brms.fpt.TNFormat;
import com.wisor.brms.fpt.RangeOfValues;
import com.wisor.brms.fpt.DateCheck;
import com.wisor.brms.fpt.Prohibited;
import com.wisor.brms.fpt.DateFormatCheck;
import com.wisor.brms.fpt.Required;
import com.wisor.brms.fpt.CapitalLetterCheck;
import com.wisor.brms.fpt.TimeFormatCheck;
import com.wisor.brms.fpt.SpecialFormat;
import com.wisor.brms.asog.dao.HOLIDAY;
import com.wisor.brms.ErrorCodeMsg;
import com.wisor.brms.ErrorResponse;
import com.wisor.brms.fpt.dao.SupplementOrderCheck;


expander FPT913_SEND.dsl
function void logMultipleError(XOMContainerBean xcb,String ruleid, String section, String field, String errorCode, String errorMessage)
    {

	ArrayList errorListIndex = (ArrayList) (xcb.getErrorListIndexMap()).get(ruleid);
	if (errorListIndex != null && errorListIndex.size() > 0)
	{
	    for (int i = 0; i < errorListIndex.size(); i++)
	    {
	    if(section.contains("[i]/"))
	    {
	    	ArrayList temp=new ArrayList();
	    	temp=(ArrayList)errorListIndex.get(i);
	    	String section1=null;
			String section2=null;
			String section12=null;
			int pos1,pos2;
			pos1=section.indexOf("[i]/");
			pos2=section.lastIndexOf("[i]");
			section1=section.substring(0,pos1);
			section2=section.substring(pos1+4,pos2);
			section12=section1 + "[" + temp.get(0) + "]/" + section2;
			String xpath = section12 + "[" + temp.get(1) + "]/" + field;
			xcb.logError(errorCode, errorMessage, xpath);
	    }
	    else
	    {

	    	int pos1;
	    	String section1=null;
	    	pos1=section.indexOf("[i]");
			section1=section.substring(0,pos1);
			String xpath = section1 + "[" + errorListIndex.get(i) + "]/" + field;
	    	xcb.logError(errorCode, errorMessage, xpath);
	    }
	    }
	}
	(xcb.getErrorListIndexMap()).remove(ruleid);
   }

  function boolean compare(XOMContainerBean xcb,int compareType, String ruleid, String section, String field, String parameter, String val2, String position1, String position2)
    {

    	ArrayList errorListIndex = new ArrayList();
    	ArrayList errorListIndexTemp1 = new ArrayList();
    	ArrayList errorListIndexTemp2 = new ArrayList();
    	int CT=compareType;
    	String param=parameter;
    	boolean finalFlag = false;
    	if(section.contains("[i]/"))
    	{
    		String section1=null;
    		String section2=null;
    		String section12=null;
    		int pos1,pos2;
    		pos1=section.indexOf("[i]/");
    		pos2=section.lastIndexOf("[i]");
    		section1=section.substring(0,pos1);
    		section2=section.substring(pos1+4,pos2);
    		XOMAccessBean accessBean1 = xcb.xpath(section1);
    		XOMContainerBean[] arr1;
    		arr1 = accessBean1.nodeSet();
    		XOMAccessBean accessBean2 =null;
    		for (int i = 0; i < arr1.length; i++)
    		{
    			section12=section1 + "[" + (i + 1) + "]/" + section2;
    			accessBean2 = xcb.xpath(section12);
    			XOMContainerBean[] arr2;
    			arr2 = accessBean2.nodeSet();
    			for(int j = 0; j < arr2.length; j++)
    			{
    				boolean flag = false;
    				XOMContainerBean xBean = arr2[j];

    				String xpath = section12 + "[" + (j + 1) + "]/" + field;
    				String content = xBean.xpath(xpath).stringValue();

    				flag=MultiRules(CT,xpath,content,param,val2,position1,position2);


    				if (flag)
    				{
    					ArrayList temp=new ArrayList();
    					temp.add(i+1);
    					temp.add(j+1);
    					errorListIndex.add(temp);
    					finalFlag = true;
    				}
    			}
    			accessBean2 =null;
			}
		}
	else
	{
		int pos1;
		String section1=null;
		section1=section.replace("[i]", "");
		XOMAccessBean accessBean = xcb.xpath(section1);
		XOMContainerBean[] arr;
		arr = accessBean.nodeSet();
		for (int i = 0; i < arr.length; i++)
		{
		    boolean flag = false;
		    XOMContainerBean xBean = arr[i];

		    String xpath = section1 + "[" + (i + 1) + "]/" + field;
		    String content = xBean.xpath(xpath).stringValue();
		    flag=MultiRules(CT,xpath,content,param,val2,position1,position2);

		    if (flag)
		    {
			errorListIndex.add(i + 1);
			finalFlag = true;
		    }
		}
	}


	errorListIndexTemp1=(ArrayList)((xcb.getErrorListIndexMap()).get(ruleid));

	errorListIndexTemp2=(ArrayList)errorListIndex.clone();

	if(errorListIndexTemp1!=null)
	{
		if(errorListIndexTemp1.isEmpty())
		{
			errorListIndex=(ArrayList)errorListIndexTemp1.clone();
		}
		else
		{
			ArrayList errorListIndexTemp3 = new ArrayList();
			for(int i = 0;i < errorListIndexTemp1.size();i++){
				for(int j = 0;j < errorListIndexTemp2.size();j++){
					if(errorListIndexTemp1.get(i).equals(errorListIndexTemp2.get(j))){
						errorListIndexTemp3.add(errorListIndexTemp1.get(i));

					}
				}
					errorListIndex=(ArrayList)errorListIndexTemp3.clone();
			}
		}
	}

	if (finalFlag)
	{
		(xcb.getErrorListIndexMap()).put(ruleid,errorListIndex);
	}
	return finalFlag;
    }
    function boolean MultiRules(int compareType, String xpath, String content, String parameter, String val2, String position1, String position2)
    {
     boolean flag=false;

     switch (compareType)
	    {
	    case 1:
		if((parameter != null) && ((new Equals()).isEqualToValues(content,parameter)))
		{
		    // log.debug("EQUALS");
		    flag = true;
		}
		break;
	    case 2:
		if ((parameter != null) && (!((new LengthCheck()).checkMaximumlength(content,Integer.parseInt(parameter)))))
		{
		    // log.debug("LENGTH IS GREATER");
		    flag = true;
		}
		break;
	    case 3:
	    	if((parameter == null) || (!(new Equals()).isEqualToValues(content,parameter)))
		{
		    // log.debug("CHARACTERS DOES NOT MATCH");
		    flag = true;
		}
		break;
	    case 4:if((new Populated()).isNotPopulated(content))
		{
		   // log.debug("FIELD NOT POPULATED");
		    flag = true;
		}
		break;
	    case 5:
		if ((new Populated()).isPopulated(content))
		{
		   // log.debug("FIELD POPULATED");
		    flag = true;
		}
		break;
	    case 6:
		if ((parameter != null) && (!((new DatatypeCheck()).checkAlphaSPSet(content,parameter))))
		{
			// log.debug("FIELD IS NOT ALPHA WITH SPECIAL CHARS");
		    flag = true;
		}
		break;
	    case 7:
		if (!((new DatatypeCheck()).checkNumeric(content)))
		{
		    // log.debug("FIELD IS NOT NUMERIC");
		    flag = true;
		}
		break;
	    case 8:
		if (!((new DatatypeCheck()).checkAlphaNumeric(content)))
		{
			    // log.debug("FIELD IS NOT ALPHANUMERIC");
			  flag = true;
		}
		break;
	    case 9:
			if ((parameter != null) && (!((new LengthCheck()).checkLength(content,Integer.parseInt(parameter)))))
			{
				    // log.debug("FIELD LENGTH CHECK");
				  flag = true;
			}
			break;
	    case 10:
	    	if ((parameter != null) && (!((new TNFormat()).tnFormatIs(content,parameter))))
			{
				    // log.debug("TELEPHONE NUM FORMAT");
				  flag = true;
			}
			break;
			case 11:
			if (!((new DatatypeCheck()).checkAlpha(content)))
			{
				    // log.debug("FIELD IS NOT ALPHA");
				  flag = true;
			}
			break;

	    case 12:
			if ((parameter != null) && (!((new DatatypeCheck()).checkAlphaNumericSPSet(content,parameter))))
			{
				// log.debug("FIELD IS ALLOW ALPHANUM WITH SPECIAL CHARS");
			    flag = true;
			}
			break;

	    default:

    }

 	return flag;
    }



    function boolean multiEquals(XOMContainerBean xcb, String ruleid, String section, String field, String valueToCompare)
    {
	return compare(xcb, 1, ruleid, section, field, valueToCompare,null,null,null);
    }

    function boolean moMaxLength(XOMContainerBean xcb, String ruleid, String section, String field, String lenghtValue)
    {
	return compare(xcb, 2, ruleid, section, field, lenghtValue,null,null,null);
    }

    function boolean multiNotEquals(XOMContainerBean xcb, String ruleid, String section, String field, String valueToCompare)
    {
	return compare(xcb, 3, ruleid, section, field, valueToCompare,null,null,null);
    }

    function boolean moNotExists(XOMContainerBean xcb, String ruleid, String section, String field)
    {
	return compare(xcb, 4, ruleid, section, field, null,null,null,null);
    }

    function boolean moExists(XOMContainerBean xcb, String ruleid, String section, String field)
    {
	return compare(xcb, 5, ruleid, section, field, null,null,null,null);
    }

    function boolean AlphaSpecialChar(XOMContainerBean xcb, String ruleid, String section, String field, String valueToCompare)
    {
	return compare(xcb, 6, ruleid, section, field, valueToCompare,null,null,null);
    }


//@@@@@@@@@@@@@@@@@@ Function Sets @@@@@@@@@@@@@@@@@@//

function void FieldShouldNotUnique(XOMContainerBean xcb, String section, String field, String eCode, String eMsg)
{
		try{
		    XOMAccessBean accessBean = xcb.xpath(section);
            XOMContainerBean arr[] = accessBean.nodeSet();
            for(int i = 0; i < arr.length; i++){
        	    for(int j = i+1; j < arr.length; j++){
        			String xpath1 = (new StringBuilder(String.valueOf(section))).append("[").append(i + 1).append("]/").append(field).toString();
        			String xpath2 = (new StringBuilder(String.valueOf(section))).append("[").append(j + 1).append("]/").append(field).toString();
        			String str1=(xcb.xpath(xpath1).stringValue());
        			String str2=(xcb.xpath(xpath2).stringValue());
        			if(((str1.equals(str2))) && ((new Populated()).isPopulated((xcb.xpath(xpath1)).stringValue()))
        			&& ((new Populated()).isPopulated((xcb.xpath(xpath2)).stringValue())))
        			{
        				xcb.logError(eCode,eMsg,xpath1);
        				break;
        			}
        	    }
            }
        }catch(Exception e){

        }
}
function boolean valueofanyField1notequalsvalueofanyField2(XOMContainerBean xcb, String section1, String section2, String field1, String field2)
{
  try{
		XOMAccessBean accessBean1 = xcb.xpath(section1);
        XOMContainerBean arr1[] = accessBean1.nodeSet();
        boolean[] flag=new boolean[arr1.length];
		ArrayList arrList1 = new ArrayList();
		ArrayList arrList2 = new ArrayList();

        for(int i = 0; i < arr1.length; i++)
        {
         String xpath1 = (new StringBuilder(String.valueOf(section1))).append("[").append(i + 1).append("]/").append(field1).toString();
         if((new Populated()).isPopulated((xcb.xpath(xpath1)).stringValue())){
			arrList1.add((xcb.xpath(xpath1)).stringValue());
         }
        }
		 for(int i = 0; i < arr1.length; i++)
        {
         String xpath2 = (new StringBuilder(String.valueOf(section2))).append("[").append(i + 1).append("]/").append(field2).toString();
         if((new Populated()).isPopulated((xcb.xpath(xpath2)).stringValue())){
			arrList2.add((xcb.xpath(xpath2)).stringValue());
         }
        }
        if (arrList1 == null && arrList2 == null)
			return false;
		for (int i = 0; i < arrList1.size(); i++) {
        for (int j = 0; j < arrList2.size(); j++) {
          if (arrList1.get(i).toString().equalsIgnoreCase(arrList2.get(j).toString())){
				return false;
			}
        }
      }
  }catch(Exception e)
  {
	return false;
  }
  return true;
}




























